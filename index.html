<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Javascript for Web Development Project</title>
    <link rel="stylesheet" media="screen" href="/css/algo_style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="/js/d3.min.js"></script>
    <script src="/js/sorting_algo.js"></script>
  </head>
  <body>
    <section class="intro" id="intro">
      <header>
        <div id = 'classname'><h1>Javascript for Web Development</h1></div>
        <div id = 'subject'><h2>Visualizing Sorting Algorithms</h2>
           <div id = 'star_relative'>
            <span class="star_tooltip">Home</span>
          <img src = '/css/icon-star-01.svg'></img>
        </div>
        <div>
      </header>
      <div class="summary" id="summary">
        <div class = "intro_txt">
          <p>
          Fascinated by Mike Bostock's famous blog post
          <a href='https://bost.ocks.org/mike/algorithms/'>Visualizing Algorithms</a>, this site is a mimic of his visualization of sorting algorithms and an attempt to improve it for observability. While Mike's article is widely spread on several algorithms
          including sampling, shuffling, sorting and maze generation, I only focused on 3 popular sorting algorithms:</p>
          <ul>
          <li>Quick Sort</li>
          <li>Merge Sort</li>
          <li>Insertion Sort </li>
          </ul>
          <p>Using animation and styling, the visualizations tried to highlight the traits of each sorting algorithm, including computational complexity, memory usage,  recursion,  stability, serial or parallel, adaptability etc. 
          </p><p>
            Please click the below icons to view each.</p>
        </div>
        <div id = 'imgbox'>
        <div class='icon_img' id='img1'><img src = '/css/icon-circles-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#quicksort';return false;" ></img>
          <span class="img_tooltip">Quick Sort</span></div>
        <div class='icon_img' id='img2'><img  src = '/css/icon-black-circle-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#mergesort';return false;"></img>
          <span class="img_tooltip">Merge Sort</span></div>
        <div class='icon_img' id='img3'><img  src = '/css/icon-zigzag-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#insertionsort';return false;"></img>
          <span class="img_tooltip">Insertion Sort</span></div>
        </div>
      </div>
    </section>
    <section class="main" id="main">
      <div id="quicksort" class="animation shuffle">
      <h3>Quick Sort</h3>
      <div class = 'back_btn'> 
        <div class = 'back_relative'>
        <img src = '/css/icon-star-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#';return false;" ></img>
      <span class = 'backbtn_tooltip'>Back to home</span> </div>
    </div>
    <p>
    Quick Sort is a divide and conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot, hence the algorithm has advantages like parallel computing, in-place sort (small footprint in memory), and recursion.
  </p><p>
    However, the efficiency of the algorithm is tied to the randomly picked pivot, hence the algorithm is not stable.   Picking a wrong pivot, like a number too big or too small,  will create a worst case scenario in the sorting process, which takes many extra rounds of comparison to complete.
  </p><p>
    There are many different versions of quickSort that pick pivot in different ways.  The following implementation used median as the pivot for any given partition.
  </p>
    </br>
      <div id = 'quicksort_vis' class='sort_vis'>
        <div id='notes' class='notes'> <span class='span_msg' id='quicksort_msg'>Click Play to start</span> </div>
        <script>
          quicksort_vis();
        </script>
        </div>
      </div>
      <div class="animation shuffle" id="mergesort">
      <h3>Merge Sort</h3>
      <div class = 'back_btn'> 
        <div class = 'back_relative'>
        <img src = '/css/icon-star-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#';return false;" ></img>
      <span class = 'backbtn_tooltip'>Back to home</span> </div>
    </div>
  <p>
    Unlike Quick Sort, which operates in-place by performing swaps, Merge Sort requires an extra copy of the array. This extra space is used to merge sorted subarrays, combining the elements from pairs of subarrays while preserving order.
  </p><p>
    Merge Sort works from the bottom-up. Initially, it merges subarrays of size one into a sorted subarray of size two using the extra array. Then, each adjacent sorted subarray of size two is merged into a sorted subarray of size four. After each pass over the whole array, mergesort doubles the size of the sorted subarrays: eight, sixteen, and so on. Eventually, this doubling merges the entire array and the algorithm terminates.
  </p><p>
    As such, Merge Sort takes more memory space in the sorting process, but the algorithm gains extraordinary efficiency by using parallel computation.  The algorithm is stable and has been widely used in the computation industry. 
  </p>
      </br>
      <div id = 'mergesort_vis' class='sort_vis'>
        <div id='notes' class='notes'> <span class='span_msg' id='mergesort_msg'>Click Play to start</span> </div>
          <script>
           mergeSort();
          </script>
   </div>
    </div>
      <div class="animation shuffle" id="insertionsort">
        <h3>Insertion Sort</h3>
      <div class = 'back_btn'> 
        <div class = 'back_relative'>
        <img src = '/css/icon-star-01.svg' onclick="document.location=document.location.toString().split('#')[0] + '#';return false;" ></img>
      <span class = 'backbtn_tooltip'>Back to home</span> </div>
    </div>
    <p>
      Insertion Sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than Quick Sort and Merge Sort. However, Insertion Sort provides several advantages:
    </p><ul>
      <li>Computational simplicity</li>
      <li> In-place swap only requires a constant amount of additional memory space</li>
      <li> Stable
      <li> More efficient in practice than most other simple quadratic algorithms such as selection sort or bubble sort</li>
      <li>Adaptive, i.e., efficient for data sets that are already substantially sorted</li>
    </ul>
  </br>
    <div id = 'insertionsort_vis' class='sort_vis'>
      <div id='notes' class='notes'> <span class='span_msg' id='insertionsort_msg'>Click Play to start</span> 
      </div>
      <script>
       insertionSort();
      </script>
      </div>
    </div>
    </section>
  </body>
</html>
